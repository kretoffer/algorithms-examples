#Алгоритмика 
## Пузырьковая сортировка
Сложность: O($n^2$)
Проходится несколько раз по всему циклу меняя местами не правильно поставленные элементы
``` C++
#include <vector>

using namespace std;

vector<int> bubbleSort(vector<int> arr) {
	int l = arr.size();
	while (l != 0) {
		int max_i = 0;
		for (int i = 1; i < l; i++) {
			if (arr[i - 1] > arr[i]) {
				swap(arr[i - 1], arr[i]);
				max_i = i;
			}
		}
		l = max_i;
	}
	return arr;
}
```
## Сортировка подсчетом
Сортирует только целые числа
Подходит только для не очень больших массивов 
Сложность O($n+MAXA$)
Создает массив длинной MAXA. Цикл проходит по изначальному массиву и считает количество определенного элемента в нем. Цикл проходит по массиву с данными о количестве элементов в массиве и создает новый массив в который добавляет все нужные элементы в необходимом поличестве 
``` C++
#include <vector>

using namespace std;

const int MAXA = 10000000;

vector<int> countingSort(vector<int> arr){
	vector<int> cnt(MAXA, 0);
	
	for (int num : arr) {
		cnt[num]++;
	}
	int j = 0;
	for (int i = 0; i<MAXA; i++){
		while (cnt[i] > 0){
			arr[j] = i;
			j++;
			cnt[i]--;
		}
	}
	return arr;
}
```
## Сортировка слиянием
Сложность: O($n\cdot\log n$)
Использует функцию merge из [[Два указателя]]
```C++
#include <vector>

using namespace std;

vector<int> mergeSort(vector<int> arr){
	if (arr.size() < 2){
		return arr;
	}
	int mid = arr.size()/2;
	vector<int> a,b;
	for (int i = 0; i<mid; i++){
		a.push_back(arr[i]);
	}
	for (int i = mid; i<arr.size(); i++){
		b.push_back(arr[i]);
	}
	return merge(mergeSort(a), mergeSort(b));
}
```