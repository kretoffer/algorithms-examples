#Алгоритмика
Метод решения задач с использыванием двух указателей на одном или двух массивах
## Слияние двух отсортированных списков
Сложность: O($n$)
Алгоритм заводит указатели для обоих массивов, сравнивает значения элементов массивов по указателю и добавляет в ответ меньший из них, при этом сдвигая указатель. После выхода одного из указателей за приделы массива добавляет оставшиеся элементы массива в ответ.
```C++
#include <vector>

using namespace std;

vector<int> merge(vector<int> a, vector<int> b){
	int i = 0, j = 0;
	vector<int> ans;
	while (i < a.size() && j < b.size()){
		if (a[i] < b[j]){
			ans.push_back(a[i]);
			i++;
		} else {
			ans.push_back(b[j]);
			j++;
		}
	}
	for (; i<a.size(); i++){
		ans.push_back(a[i]);
	}
	for (; j<b.size(); j++){
		ans.push_back(b[j]);
	}
	return ans;
}
```
## Число меньших
Нахождение количеста элементов массива $a$ меньших элементу $b_i$ для всех элементов массива.
Сложность: O($n$)
Алгоритм проходится по массиву $a$. Когда $a_j$ становится большим или равным $b_i$, в ответ для $b_i$ записывается $j$ и $i$ увеличивается на один. Процесс повторяется, пока ответ не будет записан для всех элементов массива $b$
```C++
#include <vector>

using namespace std;

vector<int> countSmaller(vector<int> a, vector<int> b){
	int j = 0;
	vector<int> reses(b.size(), 0);
	for (int i = 0; i<b.size(); i++){
		while (j<a.size() && a[j] < b[i]){
			j++;
		}
		reses[i] = j;
	}
	return reses;
}
```
## Отрезок с заданной суммой
Нахождение отрезка максимальной длины с суммой $\leq S$; $a_i \geq 0$
Сложность: O($2n$) = O(n)
Алгоритм заводит два указателя изначально находящихся в начале массива. Каждый шаг правый указатель сдвигается на 1 и если сумма становится больше $S$, то пододвигает левый указатель до тех пор, пока сумма не станет $\leq S$.
```C++
#include <vector>
#include <algorithm>

using namespace std;

int countLength(vector<int> a, int S){
	int l = 0, r = 0, res = 0, sum = 0;
	for (; l<a.size(); l++){
		while (r<a.size() && sum + a[r] <= S){
			sum += a[r];
			r++;
		}
		res = max(res, r-l);
		sum -= a[l];
	}
	return res;
}
```
## Отрезок с количеством различных $\leq k$
Нахождение отрезка максимальной длинны с количеством различных элементов $\leq k; a_i \geq 0; a_i \leq 10^6$
Сложночть: O($n+MAXA$)
Алгоритм заводит массив размером MAXA, в который записывает кол-во того или иного элемента на отрезке, с помощью этого массива он следит за кол-м различных элементов. В остальном работает как **Отрезок с заданной суммой**
```C++
#include <vector>
#include <algorithm>

using namespace std;
const int MAXA = 10000000;

int countLength(vector<int> a, int k){
	vector<int> cnt(MAXA, 0);
	int l = 0, r = 0, res = 0, dif = 0;
	for (; l<a.size(); l++){
		while (r<a.size() && (dif+1 <= k || (dif <= k && cnt[a[r]] != 0))){
			cnt[a[r]]++;
			if (cnt[a[r]] == 1){
				dif++;
			}
			r++;
		}
		res = max(res, r-l);
		cnt[a[l]]--;
		if (cnt[a[l]] == 0){
			dif--;
		}
	}
	return res;
}
```
## Отрезок с максимальной суммой
Дан массив из элементов $-10^6 \leq a_i \leq 10^6$. Нужно найти отрезок с максимальной суммой и вернуть его длину.
Сложность: O($n$)
Алгоритм заводит два указателя в начале массива. Каждый шаг алгоритм двигает правый указатель на 1. Если сумма становится меньше 0, то левый указатель передвигается к правому.
```C++
#include <vector>
#include <algorithm>

using namespace std;

int countLength(vector<int> a){
	int l = 0, r = 0, res = 0, sum = 0;
	while (r<a.size()){
		sum += a[r];
		r++;
		if (sum < 0){
			l=r;
			sum = 0;
		}
		res = max(res, sum);
	}
	return res;
}
```
