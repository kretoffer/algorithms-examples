#Алгоритмика 
%%В линейных алгоритмах будут использоваться [[Стек, очередь, дек]]%%
Операции стека, очереди и дека выполняются за O(1), по этому на базе них можно писать линейные алгоритмы.
## Найти ближайший меньший слева
Дан массив. Нужно найти ближайший меньший слева для каждого элемента этого массива.
Сложность: O($n$)
Алгоритм создает стек, в который сразу кладет 0. Алгоритм проходится по массиву удаляя в стеке элементы, пока последний элемент не станет меньше его, после чего записывает этот элемент как ответ и добавляет элемент массива в стек.
```C++
#include <vector>
#include <stack>

using namespace std;

vector<int> countLength(vector<int> a){
	stack<int> st;
	vector<int> ans;
	st.push(0);
	for (int num : a){
		while (st.top() > num){
			st.pop();
		}
		ans.push_back(st.top());
		st.push(num);
	}
	return ans;
}
```
## Прямоугольник наибольшей площади внутри гистограммы 
Дан массив высот столбиков гистограммы, ширина всех столбиков одинакова и равна 1. Необходимо найти площадь наибольшего прямоугольника внутри это гистограммы.
Сложность: O($3n$)
Мы проходимся по каждому столбику и ищем для него ближайший меньший справа и ближайший меньший слева, таким образом получаем ширину необходимого прямоугольника, высота равна высоте ввыбранного нами столбика.
```C++
int countSquare(vector<int> a){
	a.push_back(0); a.insert(a.begin(), 0);
	stack<int> st;
	st.push(0);
	vector<int> smaller_left(a.size(), 0);
	for (int i = 0; i<a.size(); i++){
		while (a[st.top()] > a[i]){
			st.pop();
		}
		smaller_left[i] = st.top();
		st.push(i);
	}
	st.push(a.size()-1);
	vector<int> smaller_right(a.size(), 0);
	for (int i = a.size()-1; i>=0; i--){
	while (a[st.top()] > a[i]){
	st.pop();
	}
	smaller_right[i] = st.top();
	st.push(i);
	}
	int res = 0;
	for (int i = 0; i<a.size(); i++){
	res = max(res, (smaller_right[i]-smaller_left[i]-1)*a[i]);
	}
	return res;
}
```
## Прямоугольник наибольшей площади внутри таблицы
Дана матрица состоящая из 0 и 1. Необходимо найти прямоугольник максимальной площади состоящий из нулей.
Сложность: O($nm$)
Алгоритм работает аналагично предъидущему, но этот алгоритм отрабатывает $m$ раз, то есть для каждой строки матрицы, беря эту строку матрицы за нижнюю часть гистограммы.
%%Для решения задачи используется функция из предъидущей задачи%%
```C++
#include <vector>
#include <stack>
#include <algorithm>

using namespace std;

int countSquareInTable(vector<vector<int>> arr){
	vector<int> gistogram(arr[0].size(), 0);
	int res = 0;
	for (int i = 0; i<arr.size(); i++){
		for (int j = 0; j<gistogram.size(); j++){
			if (arr[i][j] == 0){
				gistogram[j] += 1;
			} else {
				gistogram[j] = 0;
			}
		}
		res = max(res, countSquareInGistogram(gistogram));
	}
	return res;
}
```